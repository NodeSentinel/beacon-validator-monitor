generator client {
    provider = "prisma-client-js"
    output   = "../generated/client"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model Validator {
    id                Int     @id @map("id")
    status            Int?    @map("status")
    balance           BigInt  @map("balance")
    effectiveBalance  BigInt? @map("effective_balance")
    pubkey            String? @map("pubkey") @db.VarChar(98)
    withdrawalAddress String? @map("withdrawal_address") @db.VarChar(42)

    users User[] @relation("user_to_validator")

    @@index([status])
    @@index([pubkey])
    // TODO: do we need to index the pubkey?
    @@map("validator")
}

model validatorWithdrawals {
    slot           Int    @map("slot")
    validatorIndex String @map("validator_index") @db.VarChar(98)
    amount         BigInt @map("amount")

    @@id([slot, validatorIndex])
    @@map("validator_withdrawals")
}

model validatorDeposits {
    slot                  Int    @map("slot")
    pubkey                String @map("pubkey") @db.VarChar(98)
    withdrawalCredentials String @map("withdrawal_credentials") @db.VarChar(66)
    amount                BigInt @map("amount")
    index                 Int?   @map("index")

    @@id([slot, pubkey])
    @@map("validator_deposits")
}

enum ValidatorExitEvent {
    voluntary
    slashed
}

model validatorExits {
    index Int                @id @map("index")
    epoch Int                @map("epoch")
    slot  Int                @map("slot")
    event ValidatorExitEvent @map("event")

    @@map("validator_voluntary_exits")
}

model validatorWithdrawalsRequests {
    slot   Int    @map("slot")
    pubKey String @map("pub_key") @db.VarChar(98)
    amount BigInt @map("amount")

    @@id([slot, pubKey])
    @@map("validator_request_withdrawals")
}

model validatorConsolidationsRequests {
    slot         Int    @map("slot")
    sourcePubkey String @map("source_pubkey") @db.VarChar(98)
    targetPubkey String @map("target_pubkey") @db.VarChar(98)

    @@id([slot, sourcePubkey, targetPubkey])
    @@map("validator_request_consolidations")
}

model Epoch {
    epoch                          Int     @id @map("epoch")
    // processed flags
    processed                      Boolean @default(false) @map("processed")
    allSlotsProcessed              Boolean @default(false) @map("all_slots_processed")
    committeesFetched              Boolean @default(false) @map("committees_fetched")
    syncCommitteesFetched          Boolean @default(false) @map("sync_committees_fetched")
    validatorProposerDutiesFetched Boolean @default(false) @map("validator_proposer_duties_fetched")
    validatorsBalancesFetched      Boolean @default(false) @map("validators_balances_fetched")
    validatorsActivationFetched    Boolean @default(false) @map("validators_activation_fetched")
    rewardsFetched                 Boolean @default(false) @map("rewards_fetched")

    @@map("epoch")
}

model Slot {
    slot                     Int     @id @map("slot")
    proposerIndex            Int?    @map("proposer_index")
    blockNumber              Int?    @map("block_number")
    consensusReward          BigInt? @map("consensus_reward")
    executionReward          BigInt? @map("execution_reward")
    // Stores the number of validators per committee index as an array: [350, 340, ...], required for attestation processing
    committeesCountInSlot    Json?   @map("committees_count_in_slot")
    // processed data flags
    attestationsFetched      Boolean @default(false) @map("attestations_fetched")
    syncRewardsFetched       Boolean @default(false) @map("sync_rewards_fetched")
    consensusRewardsFetched  Boolean @default(false) @map("consensus_rewards_fetched")
    executionRewardsFetched  Boolean @default(false) @map("execution_rewards_fetched")
    // block data
    // data.message.body.proposer_slashings
    proposerSlashingsFetched Boolean @default(false) @map("proposer_slashings_fetched")
    // data.message.body.attester_slashings
    attesterSlashingsFetched Boolean @default(false) @map("attester_slashings_fetched")
    // data.message.body.deposits
    depositsFetched          Boolean @default(false) @map("deposits_fetched")
    // data.message.body.voluntary_exits
    voluntaryExitsFetched    Boolean @default(false) @map("voluntary_exits_fetched")
    // data.message.body.execution_payload.withdrawals
    epWithdrawalsFetched     Boolean @default(false) @map("ep_withdrawals_fetched")
    // data.message.body.execution_requests.deposits
    erDepositsFetched        Boolean @default(false) @map("er_deposits_fetched")
    // data.message.body.execution_requests.withdrawals
    erWithdrawalsFetched     Boolean @default(false) @map("er_withdrawals_fetched")
    // data.message.body.execution_requests.consolidations
    erConsolidationsFetched  Boolean @default(false) @map("er_consolidations_fetched")

    processed Boolean @default(false) @map("processed")

    @@index([slot, processed])
    @@map("slot")
}

// Committee is a list of validators that were assigned to a slot.
// TODO: add partition table
model Committee {
    slot                 Int  @map("slot")
    index                Int  @map("index") @db.SmallInt // indicates what position in the epoch this slot is in
    validatorIndex       Int  @map("validator_index")
    aggregationBitsIndex Int  @map("aggregation_bits_index") @db.SmallInt // indicates what position in the aggregation bits this validator was assigned to
    attestationDelay     Int? @map("attestation_delay") @db.SmallInt

    @@id([slot, index, aggregationBitsIndex]) // used to update attestation delays
    @@index([slot, validatorIndex, attestationDelay]) // used to query attestations delays for a validator
    @@map("committee")
}

model SyncCommittee {
    fromEpoch           Int  @map("from_epoch")
    toEpoch             Int  @map("to_epoch")
    validators          Json // Array of validator indices as strings: ["1", "2", "3", ...]
    validatorAggregates Json @map("validator_aggregates") // Array of arrays of validator indices as strings: [["1", "2"], ["3", "4"], ...]

    // TODO: check this index
    @@id([fromEpoch, toEpoch])
    @@map("sync_committee")
}

model syncCommitteeRewards {
    slot                Int    @map("slot")
    validatorIndex      Int    @map("validator_index")
    syncCommitteeReward BigInt @map("sync_committee_reward")

    @@id([slot, validatorIndex])
    @@map("sync_committee_rewards")
}

model epochRewards {
    epoch            Int    @map("epoch")
    validatorIndex   Int    @map("validator_index")
    head             BigInt @map("head")
    target           BigInt @map("target")
    source           BigInt @map("source")
    inactivity       BigInt @map("inactivity")
    missedHead       BigInt @map("missed_head")
    missedTarget     BigInt @map("missed_target")
    missedSource     BigInt @map("missed_source")
    missedInactivity BigInt @map("missed_inactivity")

    @@id([epoch, validatorIndex])
    @@map("epoch_rewards")
}

//-------------------------------------
// Aggregation tables
//-------------------------------------
model HourlyValidatorStats {
    datetime          DateTime @map("datetime") @db.Timestamp // dd-mm-yyyy-hh
    validatorIndex    Int      @map("validator_index")
    attestationsCount Int?     @map("missed_attestations_count") @db.SmallInt // TODO: remove this field
    clRewards         BigInt?  @map("cl_rewards")
    clMissedRewards   BigInt?  @map("cl_missed_rewards")

    @@id([datetime, validatorIndex])
    @@map("hourly_validator_stats")
}

//-------------------------------------
// API
//-------------------------------------

model User {
    id                           BigInt              @id @map("id")
    loginId                      String              @unique @default(nanoid()) @map("login_id")
    userId                       BigInt              @unique @map("user_id")
    chatId                       BigInt              @unique @map("chat_id")
    username                     String              @unique @map("username")
    messageId                    BigInt?             @map("message_id")
    lastClaimed                  DateTime?           @map("last_claimed")
    hasBlockedBot                Boolean             @default(false) @map("has_blocked_bot")
    createdAt                    DateTime            @default(now()) @map("created_at")
    performanceNotif             DateTime?           @map("performance_notif")
    performanceThreshold         Int                 @default(90) @map("performance_threshold")
    inactiveNotif                DateTime?           @map("inactive_notif")
    inactiveOnMissedAttestations Int                 @default(3) @map("inactive_on_missed_attestations")
    validators                   Validator[]         @relation("user_to_validator")
    withdrawalAddresses          WithdrawalAddress[] @relation("user_to_withdrawal_address")
    feeRewardAddresses           FeeRewardAddress[]  @relation("user_to_fee_reward_address")

    @@map("user")
}

//-------------------------------------
// remove
//-------------------------------------

model WithdrawalAddress {
    address String @id @map("address")
    users   User[] @relation("user_to_withdrawal_address")

    @@map("withdrawal_address")
}

model FeeRewardAddress {
    address String  @id @map("address")
    users   User[]  @relation("user_to_fee_reward_address")
    userId  BigInt? @map("user_id")

    @@map("fee_reward_address")
}

model DailyValidatorStats {
    validatorIndex Int      @map("validator_index")
    date           DateTime @db.Date

    head             BigInt? @map("head")
    target           BigInt? @map("target")
    source           BigInt? @map("source")
    inactivity       BigInt? @map("inactivity")
    syncCommittee    BigInt? @map("sync_committee")
    blockReward      BigInt? @map("block_reward")
    missedHead       BigInt? @map("missed_head")
    missedTarget     BigInt? @map("missed_target")
    missedSource     BigInt? @map("missed_source")
    missedInactivity BigInt? @map("missed_inactivity")

    attestationsMissed Int? @map("attestations_missed")

    @@id([validatorIndex, date])
    @@index([date])
}

model LastSummaryUpdate {
    id                    Int       @id @default(autoincrement()) @map("id")
    hourlyValidatorStats  DateTime? @map("hourly_validator_stats")
    dailyValidatorStats   DateTime? @map("daily_validator_stats") @db.Date
    weeklyValidatorStats  DateTime? @map("weekly_validator_stats")
    monthlyValidatorStats DateTime? @map("monthly_validator_stats")
    yearlyValidatorStats  DateTime? @map("yearly_validator_stats")

    @@map("last_summary_update")
}

model ValidatorsStats {
    validatorId     Int
    validatorStatus Int?
    oneHourMissed   Int?
    lastMissed      Int[] // Array of last missed slots: [1020, 1021, .., 1040]

    dailyCLRewards BigInt?
    dailyELRewards BigInt?

    weeklyCLRewards BigInt?
    weeklyELRewards BigInt?

    monthlyCLRewards BigInt?
    monthlyELRewards BigInt?

    timestamp DateTime

    @@id([validatorId])
}

model HourlyBlockAndSyncRewards {
    validatorIndex Int
    hour           Int // 0-23
    date           DateTime @db.Date // dd-mm-yyyy

    blockReward   BigInt? // Reward for proposing a block
    syncCommittee BigInt? // Rewarded for participating in the sync committee

    @@id([validatorIndex, date, hour])
    @@index([date, hour])
}

model ExecutionRewards {
    address     String
    timestamp   DateTime
    amount      Decimal  @db.Decimal(78, 0)
    blockNumber Int      @id

    @@index([timestamp, address])
}

/// Global daily validator stats (counts + averages in gwei)
model BeaconDailyValidatorStats {
    date DateTime @id @db.Date

    // counts
    pendingQueued Int @default(0) @map("pending_queued")
    activeOngoing Int @default(0) @map("active_ongoing")
    activeExiting Int @default(0) @map("active_exiting")

    // averages (store floored bigint in gwei)
    balance          BigInt? @map("avg_balance")
    effectiveBalance BigInt? @map("avg_effective_balance")

    @@map("beacon_daily_validator_stats")
}
